# 1. 测试分类

**功能测试**

关注功能正常

包含兼容性测试

**性能测试**

前端性能、后端性能

**安全测试**

关注传输、存储等安全

**特性测试**

特性指平台差异(部分兼容性测试)

PC端鼠标，键盘操作特性(Tab键等)；

如手机触屏操作，横竖屏，中断恢复(来电)等。

# 2. 软件测试的概念

## 2.1 定义

使用**人工或自动**的手段，来运行或测定某个**软件系统的过程**，其目的在于检验它是否满足规定的需求，或弄清预期结果与实际结果之间的差别。

## 2.2 测试目的

测试是通过程序的执行过程发现问题，发现至今未发现的问题，检查系统是否满足需求。

## 2.3 测试对象

程序、数据、文档

## 2.4 软件错误占比

属于**需求分析和软件设计错误**的约占64%

属于**程序编写错误**的仅占36％

# 3. 软件开发模型

## 3.1 瀑布模型

<img src="https://gitee.com/qqy_xz/study/raw/master/0524-1.png" alt="0524-1" style="zoom:50%;" />

**特点**

- 软件开发的各项活动**严格按照这条线进行**，只有当一个阶段任务完成之后才能开始下一个阶段
- 软件开发的每一个阶段都要有结果产出，前一阶段的输出文本为下一阶段的输入文本

**优点**

- 整个项目划分了**清晰的检查点**
- 当一个阶段完成之后，只需要把全部精力放置在后面的开发上即可
- 有利于**大型软件开发人员的组织管理**及工具的使用与研究，可以提高开发的效率。

**缺点**

- 严格按照线性方式进行的，**无法适应用户需求变更**
- 用户只能等到最后才能看到开发成果，如果开发人员与客户对需求理解有偏差，到最后开发完成后最终成果与客户需求可能会差之千里。
- 如果早期犯的错误在项目完成后才发现，此时再修改原来的错误需要付出巨大的代价。
- 瀑布模型要求每一个阶段必须有结果产出，这就势必增加了文档的数量，使软件开发的工作量变大。
- 现代软件开发各阶段一般不是线性的，因此瀑布模型逐渐被抛弃

## 3.2 快速原型

<img src="https://gitee.com/qqy_xz/study/raw/master/0524-2.png" alt="0524-2" style="zoom:50%;" />

**特点**

与瀑布模型正好相反

①根据用户需求快速构造岀一个可以运行的软件原型，向用户展示待开发软件的全部或部分功能和性能

②客户对该原型进行审核评价，然后给出更具体的需求意见，

③开发人员与客户达成最终共识，确定客户的真正需求，然后开始真正的软件开发。

**原型类型**

- 探索型原型：目的是要弄清用户的需求,探索各种方案的可行性。它主要针对**开发目标模糊**。
- 实验型原型：主要用于**设计阶段**，实现方案是否合适,能否实现
- 演化型原型：主要用于及早向用户提交一个原型系统（系统的框架、主要功能），在得到用户的认可后,将原型系统不断扩充演变为最终的软件系统

**优点**

- 克服瀑布模型的缺点,**减少由于软件需求不明确**带来的开发风险

**缺点**

- **准确地设计出软件原型**存在定的难度
- 不利于开发人员**对产品进行扩展**

## 3.3 螺旋模型

<img src="https://gitee.com/qqy_xz/study/raw/master/0524-3.png" alt="0524-3" style="zoom:50%;" />

**特点**

- 该模型**融合了瀑布模型、快速原型模型**，引入了其他模型所忽略的**风险分析**，适合于**大规模软件项目**
- 采用瀑布模型将整个项目开发过程划分为几个不同的阶段，每个阶段按部就班地执行
- 每个阶段在开始之前都要进行**风险评估**，如果**能消除重大风险**则可以开始该阶段任务
- 首先构建**软件原型**，根据快速原型模型完成这个**迭代过程**，产出最终完善的产品，然后进入下一个阶段
- 每一个选代都需要经过这4个步骤（制定计划、风险分析、实施工程、客户评估），直到最后得到完善的产品，可以进行提交。

**优点**

- 设计灵活,可以在项目的各个阶段进行变更.
- 以小的分段来构建大型系统，成本易计算
- 客户始终参为保证了项目不偏离正确方向以及项目的可控性

**缺点**

- 很难让用户确信这种演化方法的结果是可以控制的.
- 建设周期长,而软件技术发展比较快,经常出现软件开发完毕后和当前的技术水平有了较大的差距,无法满足当前用户需求.

## 3.4 增量模型（演化、迭代）

<img src="https://gitee.com/qqy_xz/study/raw/master/0524-4.png" alt="0524-4" style="zoom: 50%;" />

**特点**

- 将一个完整的软件拆分成不同的组件，然后逐个组件地开发测试
- 每完成一个组件就展现给客户，让客户确认这一部件功能和性能是否达到客户需求
- 最终确定无误，将组件集成到软件体系结构中

**优点**

- 很好地适应客户需求变更，逐个组件地交付产品
- 如果某个组件没有满足客户需求，则**只需要更改这一个组件**，降低了软件开发的成本与风险

**缺点**

会有集成失败的风险

逐个组件地开发修改，很容易退化为**“边做边改”**的开发形式，从而失去对软件开发过程的整体控制

## 3.5 敏捷开发模型

**特点**

- 以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。
- 软件项目在构建初期被拆分为多个**相互联系而又独立运行**的子项目，然后迭代完成各个子项目。
- 软件一直处于可使用状态
- 软件开发不再是线性的,开发的同时也会进行测试工作,甚至可以提前写好测试代码
- 相比于工具、文档，更注重人与人之间的交流沟通

**优点**

可以及时响应客户需求变更,不断适应新的趋势

**缺点**

开发灵活的同时也带来了一定程度的混乱

缺乏文档资料，软件版本的可重现性、可回溯性低

对于大型姓名，人员越多，面对面的有效沟通越困难

# 4. 软件测试模型

　v模型适用于中小企业；

　w模型适用于中大型企业（因为人员要求高）

## 4.1 V模型

<img src="https://gitee.com/qqy_xz/study/raw/master/0524-5.jpg" alt="0524-5" style="zoom: 67%;" />

客户需求分析、软件需求分析、概要设计、详细设计、软件编码；单元测试、集成测试、系统测试、验收测试

**优点**

- 包含了底层测试（单元测试）和高层测试（系统测试）；
- 清楚的标识了开发和测试的各个阶段；
- 自上而下逐步求精，每个阶段分工明确，便于整体项目的把控。

**缺点**

- 测试工作在编码之后，就导致错误不能及时的进行修改；
- 实际工作中，需求经常变化，导致v模型步骤，反复执行，返工量很大，灵活度较低。

**解决**

- 软件开发时，研发人员和测试人员需要同时工作
- 在软件做需求分析的同时就会有测试用例的跟踪，这样，可以尽快找出程序错误和需求偏离

## 4.2 W模型

<img src="https://gitee.com/qqy_xz/study/raw/master/0524-6.png" alt="0524-6" style="zoom: 67%;" />

**优点**

- 需求和设计同样要测试
- 更早的介入测试，可以发现初期的缺陷，修复成本低
- 分阶段工作，方便项目整体管理

**缺点**

- 开发和测试依然是线性的关系，需求的变更和调整，依然不方便；
- 如果没有文档，根本无法执行w模型
- 对于项目组成员的技术要求更高
  



